/**
 * Chrome Extension Debug MCP - RemoteTransport ÊµãËØï
 * 
 * ÊµãËØïHTTP/SSEËøúÁ®ã‰º†ËæìÊ®°ÂºèÁöÑÊâÄÊúâ47‰∏™Â∑•ÂÖ∑
 */

import { spawn } from 'child_process';
import path from 'path';
import { fileURLToPath } from 'url';
import fetch from 'node-fetch';
import EventSource from 'eventsource';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class RemoteTransportTester {
  constructor() {
    this.mcpProcess = null;
    this.serverPort = 3000;
    this.serverUrl = `http://localhost:${this.serverPort}`;
    this.requestId = 1;
    this.results = {
      total: 0,
      passed: 0,
      failed: 0,
      tools: []
    };
  }

  async start() {
    console.log('üöÄ Starting RemoteTransport Test...\n');
    
    // ÂêØÂä®MCPÊúçÂä°Âô®ÔºàRemoteÊ®°ÂºèÔºâ
    await this.startMcpServer();
    
    // Á≠âÂæÖÊúçÂä°Âô®ÂàùÂßãÂåñ
    await this.sleep(3000);
    
    // ÊµãËØïËøûÊé•
    await this.testConnection();
    
    // ËøûÊé•Chrome
    await this.testAttachToChrome();
    
    // ÊµãËØïÊâÄÊúâÂ∑•ÂÖ∑ÂàÜÁ±ª
    await this.testBasicTools();
    await this.testExtensionTools();
    await this.testUIAutomationTools();
    await this.testQuickTools();
    
    // ÊµãËØïSSE‰∫ã‰ª∂ÊµÅ
    await this.testSSEStream();
    
    // ÁîüÊàêÊä•Âëä
    this.generateReport();
    
    // Ê∏ÖÁêÜ
    await this.cleanup();
  }

  async startMcpServer() {
    console.log('üì° Starting MCP Server (RemoteTransport mode)...');
    
    const serverPath = path.join(__dirname, '../build/remote.js');
    
    this.mcpProcess = spawn('node', [serverPath, '--port', this.serverPort, '--chrome-port', '9222'], {
      stdio: 'inherit'
    });

    console.log(`‚úÖ MCP Server started on ${this.serverUrl}\n`);
  }

  async testConnection() {
    console.log('üîå Testing HTTP connection...\n');
    
    try {
      const response = await fetch(`${this.serverUrl}/health`);
      if (response.ok) {
        console.log('‚úÖ HTTP connection successful\n');
      } else {
        throw new Error(`HTTP ${response.status}`);
      }
    } catch (error) {
      console.error('‚ùå Connection failed:', error.message);
      throw error;
    }
  }

  async sendRequest(method, params = {}) {
    const id = this.requestId++;
    
    const request = {
      jsonrpc: '2.0',
      id,
      method,
      params
    };

    try {
      const response = await fetch(`${this.serverUrl}/message`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(request)
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      return data;
    } catch (error) {
      throw new Error(`Request failed: ${error.message}`);
    }
  }

  async testTool(toolName, args = {}) {
    this.results.total++;
    console.log(`  Testing ${toolName}...`);
    
    try {
      const response = await this.sendRequest('tools/call', {
        name: toolName,
        arguments: args
      });

      if (response.result) {
        this.results.passed++;
        this.results.tools.push({
          name: toolName,
          status: 'PASS',
          transport: 'remote'
        });
        console.log(`  ‚úÖ ${toolName} - PASS`);
        return response.result;
      } else if (response.error) {
        throw new Error(response.error.message);
      }
    } catch (error) {
      this.results.failed++;
      this.results.tools.push({
        name: toolName,
        status: 'FAIL',
        transport: 'remote',
        error: error.message
      });
      console.log(`  ‚ùå ${toolName} - FAIL: ${error.message}`);
      return null;
    }
  }

  async testAttachToChrome() {
    console.log('üîß Testing attach_to_chrome...\n');
    await this.testTool('attach_to_chrome', { port: 9222 });
    await this.sleep(1000);
  }

  async testBasicTools() {
    console.log('\nüìä Testing Basic Debugging Tools (11)...\n');
    
    // Ê†áÁ≠æÈ°µÊìç‰Ωú
    const tabs = await this.testTool('list_tabs');
    
    if (tabs && tabs.length > 0) {
      const tabId = tabs[0].id;
      await this.testTool('switch_tab', { tabId });
    }
    
    await this.testTool('new_tab', { url: 'https://example.com' });
    await this.testTool('screenshot', { path: './test-remote-screenshot.png' });
    
    // ‰ª£Á†ÅÊâßË°å
    await this.testTool('evaluate', { 
      expression: 'document.title' 
    });
    
    // Êó•ÂøóÊî∂ÈõÜ
    await this.testTool('get_console_logs');
    
    // ‰∫§‰∫í
    await this.testTool('click', { selector: 'body' });
    await this.testTool('type', { 
      selector: 'body', 
      text: 'test',
      clear: false 
    });
  }

  async testExtensionTools() {
    console.log('\nüîå Testing Extension-Specific Tools (24)...\n');
    
    // Êâ©Â±ïÂèëÁé∞
    const extensions = await this.testTool('list_extensions');
    
    if (!extensions || extensions.length === 0) {
      console.log('  ‚ö†Ô∏è  No extensions found, skipping extension-specific tests');
      return;
    }
    
    const testExtension = extensions.find(e => 
      e.name && e.name.includes('Enhanced MCP')
    );
    
    if (!testExtension) {
      console.log('  ‚ö†Ô∏è  test-extension-enhanced not found, using first extension');
      const extensionId = extensions[0].id;
      await this.runExtensionTests(extensionId);
    } else {
      await this.runExtensionTests(testExtension.id);
    }
  }

  async runExtensionTests(extensionId) {
    console.log(`  Using extension: ${extensionId}\n`);
    
    // ‰∏ä‰∏ãÊñáÁÆ°ÁêÜ
    await this.testTool('list_extension_contexts', { extensionId });
    await this.testTool('switch_extension_context', { 
      extensionId, 
      contextType: 'background' 
    });
    
    // Êó•ÂøóÂíåÂ≠òÂÇ®
    await this.testTool('get_extension_logs', { extensionId });
    await this.testTool('inspect_extension_storage', { 
      extensionId,
      storageTypes: ['local', 'sync']
    });
    
    // ÂÜÖÂÆπËÑöÊú¨
    await this.testTool('content_script_status', { extensionId });
    
    // Ê∂àÊÅØÂíåAPI
    await this.testTool('monitor_extension_messages', { 
      extensionId, 
      duration: 3000 
    });
    await this.testTool('track_extension_api_calls', { 
      extensionId,
      apiCategories: ['storage', 'tabs'],
      duration: 3000
    });
    
    // ÊÄßËÉΩÂàÜÊûê
    await this.testTool('analyze_extension_performance', { 
      extensionId,
      testUrl: 'https://example.com',
      duration: 2000
    });
    
    // ËÆæÂ§áÊ®°Êãü
    await this.testTool('emulate_cpu', { rate: 4 });
    await this.testTool('emulate_network', { 
      conditions: {
        offline: false,
        downloadThroughput: 1.5 * 1024 * 1024 / 8,
        uploadThroughput: 750 * 1024 / 8,
        latency: 40
      }
    });
    
    // ÁΩëÁªúÁõëÊéß
    await this.testTool('track_extension_network', { 
      extensionId, 
      duration: 3000 
    });
    await this.testTool('list_extension_requests', { extensionId });
    await this.testTool('analyze_extension_network', { 
      extensionId,
      duration: 3000
    });
    
    // ÂºÄÂèëËÄÖÂ∑•ÂÖ∑
    await this.testTool('check_extension_permissions', { extensionId });
    await this.testTool('audit_extension_security', { extensionId });
    await this.testTool('check_extension_updates', { extensionId });
  }

  async testUIAutomationTools() {
    console.log('\nüéØ Testing UI Automation Tools (13)...\n');
    
    // DOMÂø´ÁÖß
    const snapshot = await this.testTool('take_snapshot');
    
    if (snapshot && snapshot.elements && snapshot.elements.length > 0) {
      const firstElement = snapshot.elements[0];
      if (firstElement.uid) {
        await this.testTool('click_by_uid', { uid: firstElement.uid });
      }
    }
    
    // Êô∫ËÉΩÁ≠âÂæÖ
    await this.testTool('wait_for_element', {
      strategies: [
        { type: 'selector', value: 'body' }
      ],
      timeout: 3000
    });
    
    // È´òÁ∫ß‰∫§‰∫í
    await this.testTool('hover_element', { selector: 'body' });
    await this.testTool('handle_dialog', { action: 'accept' });
  }

  async testQuickTools() {
    console.log('\n‚ö° Testing Quick Tools (2)...\n');
    
    const extensions = await this.sendRequest('tools/call', {
      name: 'list_extensions',
      arguments: {}
    });
    
    if (extensions && extensions.result && extensions.result.length > 0) {
      const extensionId = extensions.result[0].id;
      
      await this.testTool('quick_extension_debug', { extensionId });
      await this.testTool('quick_performance_check', { 
        extensionId,
        testUrl: 'https://example.com'
      });
    }
  }

  async testSSEStream() {
    console.log('\nüì° Testing SSE Event Stream...\n');
    
    return new Promise((resolve, reject) => {
      const eventSource = new EventSource(`${this.serverUrl}/sse`);
      let eventCount = 0;
      const timeout = setTimeout(() => {
        eventSource.close();
        if (eventCount > 0) {
          console.log(`‚úÖ SSE Stream Test - Received ${eventCount} events\n`);
          resolve();
        } else {
          console.log('‚ö†Ô∏è  SSE Stream Test - No events received\n');
          resolve();
        }
      }, 5000);

      eventSource.onmessage = (event) => {
        eventCount++;
        try {
          const data = JSON.parse(event.data);
          console.log(`  üì® SSE Event ${eventCount}: ${data.type || 'message'}`);
        } catch (e) {
          console.log(`  üì® SSE Event ${eventCount}: ${event.data}`);
        }
      };

      eventSource.onerror = (error) => {
        clearTimeout(timeout);
        eventSource.close();
        console.log('‚ö†Ô∏è  SSE connection error (expected if not implemented)\n');
        resolve();
      };
    });
  }

  generateReport() {
    console.log('\n' + '='.repeat(60));
    console.log('üìä RemoteTransport Test Report');
    console.log('='.repeat(60));
    console.log(`\nTotal Tests: ${this.results.total}`);
    console.log(`Passed: ${this.results.passed} ‚úÖ`);
    console.log(`Failed: ${this.results.failed} ‚ùå`);
    console.log(`Success Rate: ${(this.results.passed / this.results.total * 100).toFixed(1)}%`);
    
    if (this.results.failed > 0) {
      console.log('\n‚ùå Failed Tools:');
      this.results.tools
        .filter(t => t.status === 'FAIL')
        .forEach(t => {
          console.log(`  - ${t.name}: ${t.error}`);
        });
    }
    
    console.log('\n‚úÖ RemoteTransport Test Complete!');
    console.log('='.repeat(60) + '\n');
  }

  async cleanup() {
    if (this.mcpProcess) {
      this.mcpProcess.kill();
    }
    await this.sleep(1000);
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// ËøêË°åÊµãËØï
const tester = new RemoteTransportTester();
tester.start().catch(error => {
  console.error('‚ùå Test failed:', error);
  process.exit(1);
});

