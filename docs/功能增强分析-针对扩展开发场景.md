# Chrome Extension Debug MCP åŠŸèƒ½å¢å¼ºåˆ†ææŠ¥å‘Š
**é’ˆå¯¹æ‰©å±•å¼€å‘åœºæ™¯çš„æ·±åº¦åˆ†æ**

**ç”Ÿæˆæ—¶é—´**: 2025-01-10  
**åˆ†æåŸºç¡€**: 
- Chrome DevTools MCP v0.6.1 (Googleå®˜æ–¹)
- Chrome Extension Debug MCP v4.0.0 (å½“å‰é¡¹ç›®)
- CHROME-DEVTOOLS-MCP-ANALYSIS.md

---

## ğŸ“Š æ‰§è¡Œæ‘˜è¦

é€šè¿‡å¯¹æ¯”Googleå®˜æ–¹Chrome DevTools MCPå’Œå½“å‰Chrome Extension Debug MCPé¡¹ç›®ï¼Œå‘ç°**8ä¸ªå…³é”®åŠŸèƒ½é¢†åŸŸ**éœ€è¦å¢å¼ºï¼Œä»¥æ›´å¥½åœ°æœåŠ¡äºChromeæ‰©å±•å¼€å‘å’Œè°ƒè¯•åœºæ™¯ã€‚

**æ ¸å¿ƒå‘ç°**:
- âœ… **å·²æœ‰ä¼˜åŠ¿**: æ‰©å±•ä¸“ä¸šè°ƒè¯•èƒ½åŠ›ï¼ˆ10ä¸ªç‹¬æœ‰å·¥å…·ï¼‰
- âš ï¸ **éœ€è¦å¢å¼º**: æ€§èƒ½åˆ†ææ·±åº¦ã€äº¤äº’è‡ªåŠ¨åŒ–ã€è®¾å¤‡æ¨¡æ‹Ÿ
- ğŸ†• **å»ºè®®æ–°å¢**: 7ä¸ªé«˜ä»·å€¼å·¥å…·ï¼Œè¦†ç›–5å¤§å…³é”®åœºæ™¯

---

## ğŸ¯ Part 1: å½“å‰é¡¹ç›®ä¼˜åŠ£åŠ¿åˆ†æ

### âœ… æ ¸å¿ƒä¼˜åŠ¿ï¼ˆä¿æŒå¹¶å¼ºåŒ–ï¼‰

#### 1. **æ‰©å±•ä¸“ä¸šè°ƒè¯•èƒ½åŠ›** â­â­â­â­â­
**ç°æœ‰å·¥å…·ï¼ˆ10ä¸ªï¼‰**:
- `list_extensions` - æ‰©å±•å‘ç°
- `get_extension_logs` - æ—¥å¿—èšåˆï¼ˆå¢å¼ºç‰ˆï¼‰
- `list_extension_contexts` - ä¸Šä¸‹æ–‡ç®¡ç†
- `switch_extension_context` - ä¸Šä¸‹æ–‡åˆ‡æ¢
- `inspect_extension_storage` - å­˜å‚¨æ£€æŸ¥
- `monitor_extension_messages` - æ¶ˆæ¯ç›‘æ§
- `track_extension_api_calls` - APIè°ƒç”¨è¿½è¸ª
- `test_extension_on_multiple_pages` - æ‰¹é‡æµ‹è¯•
- `inject_content_script` - è„šæœ¬æ³¨å…¥
- `content_script_status` - æ³¨å…¥çŠ¶æ€æ£€æµ‹

**å·®å¼‚åŒ–ä»·å€¼**: Chrome DevTools MCPå®Œå…¨æ²¡æœ‰è¿™äº›èƒ½åŠ›ï¼Œè¿™æ˜¯æ ¸å¿ƒç«äº‰åŠ›ã€‚

#### 2. **åˆæ­¥æ€§èƒ½åˆ†æèƒ½åŠ›** â­â­â­
**ç°æœ‰å·¥å…·ï¼ˆ3ä¸ªï¼‰**:
- `analyze_extension_performance` - æ€§èƒ½åˆ†æ
- `track_extension_network` - ç½‘ç»œç›‘æ§
- `measure_extension_impact` - å½±å“é‡åŒ–

**å½“å‰å®ç°**:
- âœ… åŸºç¡€traceå½•åˆ¶
- âœ… Web Vitalsé›†æˆï¼ˆä½¿ç”¨web-vitalsåº“ï¼‰
- âœ… CPU/å†…å­˜/æ‰§è¡Œæ—¶é—´è®¡ç®—
- âš ï¸ ç¼ºå°‘æ·±åº¦traceè§£æ
- âš ï¸ ç¼ºå°‘Performance Insights

#### 3. **è¿œç¨‹è°ƒè¯•èƒ½åŠ›** â­â­â­â­
**ç°æœ‰ç‰¹æ€§**:
- HTTP/SSEåŒä¼ è¾“æ”¯æŒ
- è·¨ç½‘ç»œè¿œç¨‹è®¿é—®
- å›¢é˜Ÿåä½œå‹å¥½

**å·®å¼‚åŒ–ä»·å€¼**: Chrome DevTools MCPåªæ”¯æŒstdioä¼ è¾“ã€‚

### âš ï¸ éœ€è¦å¢å¼ºçš„é¢†åŸŸ

#### 1. **æ€§èƒ½åˆ†ææ·±åº¦ä¸è¶³** 
**é—®é¢˜**:
- âŒ æœªä½¿ç”¨chrome-devtools-frontendåº“
- âŒ æ²¡æœ‰Performance Insightsç³»ç»Ÿ
- âŒ Traceè§£ææ·±åº¦æœ‰é™
- âŒ ç¼ºå°‘è‡ªåŠ¨åŒ–æ€§èƒ½æ´å¯Ÿ

**å½±å“**: æ— æ³•æä¾›Chrome DevToolsçº§åˆ«çš„ä¸“ä¸šæ€§èƒ½åˆ†æã€‚

#### 2. **äº¤äº’è‡ªåŠ¨åŒ–èƒ½åŠ›å¼±**
**é—®é¢˜**:
- âŒ ç¼ºå°‘dragï¼ˆæ‹–æ‹½ï¼‰å·¥å…·
- âŒ ç¼ºå°‘hoverï¼ˆæ‚¬åœï¼‰å·¥å…·
- âŒ ç¼ºå°‘fill_formï¼ˆæ‰¹é‡è¡¨å•å¡«å……ï¼‰å·¥å…·
- âŒ ç¼ºå°‘upload_fileï¼ˆæ–‡ä»¶ä¸Šä¼ ï¼‰å·¥å…·
- âŒ ç¼ºå°‘handle_dialogï¼ˆå¯¹è¯æ¡†å¤„ç†ï¼‰å·¥å…·

**å½±å“**: æ— æ³•è‡ªåŠ¨åŒ–æµ‹è¯•æ‰©å±•çš„å¤æ‚UIäº¤äº’åœºæ™¯ã€‚

#### 3. **è®¾å¤‡æ¨¡æ‹Ÿèƒ½åŠ›ç¼ºå¤±**
**é—®é¢˜**:
- âŒ æ— CPUèŠ‚æµï¼ˆthrottlingï¼‰åŠŸèƒ½
- âŒ æ— ç½‘ç»œèŠ‚æµåŠŸèƒ½
- âŒ æ— æ³•æ¨¡æ‹Ÿä½æ€§èƒ½è®¾å¤‡

**å½±å“**: æ— æ³•æµ‹è¯•æ‰©å±•åœ¨å¼±è®¾å¤‡/å¼±ç½‘ç¯å¢ƒä¸‹çš„è¡¨ç°ã€‚

#### 4. **DOMå¿«ç…§ä¸å®šä½ç³»ç»Ÿç¼ºå¤±**
**é—®é¢˜**:
- âŒ æ²¡æœ‰UID-basedå…ƒç´ å®šä½
- âŒ æ²¡æœ‰å¯è®¿é—®æ€§æ ‘å¿«ç…§
- âŒ å…ƒç´ å®šä½ä¾èµ–ä¼ ç»Ÿselector

**å½±å“**: AIé©±åŠ¨çš„è‡ªåŠ¨åŒ–æµ‹è¯•èƒ½åŠ›å—é™ã€‚

#### 5. **æ™ºèƒ½ç­‰å¾…æœºåˆ¶ä¸å®Œå–„**
**é—®é¢˜**:
- âš ï¸ ä½¿ç”¨setTimeoutåŸºç¡€ç­‰å¾…
- âŒ ç¼ºå°‘Locator API
- âŒ ç¼ºå°‘ARIA selectoræ”¯æŒ
- âŒ ç¼ºå°‘Locator.raceç«æ€ç­‰å¾…

**å½±å“**: è‡ªåŠ¨åŒ–æµ‹è¯•ç¨³å®šæ€§å’Œçµæ´»æ€§ä¸è¶³ã€‚

---

## ğŸš€ Part 2: é’ˆå¯¹æ‰©å±•å¼€å‘çš„åŠŸèƒ½å¢å¼ºå»ºè®®

### ä¼˜å…ˆçº§åˆ†çº§

| ä¼˜å…ˆçº§ | è¯´æ˜ | å¼€å‘å‘¨æœŸ | ROI |
|--------|------|----------|-----|
| P0 | å…³é”®ç¼ºå¤±ï¼Œä¸¥é‡å½±å“ç«äº‰åŠ› | 2-4å‘¨ | â­â­â­â­â­ |
| P1 | é‡è¦å¢å¼ºï¼Œæ˜¾è‘—æå‡ä½“éªŒ | 1-2å‘¨ | â­â­â­â­ |
| P2 | æœ‰ä»·å€¼å¢å¼ºï¼Œé”¦ä¸Šæ·»èŠ± | 1å‘¨ | â­â­â­ |
| P3 | å¯é€‰å¢å¼ºï¼Œé•¿æœŸè§„åˆ’ | 1-2å‘¨ | â­â­ |

---

## ğŸ”´ P0: å…³é”®åŠŸèƒ½å¢å¼ºï¼ˆå¿…é¡»å®ç°ï¼‰

### 1. é›†æˆChrome DevTools Trace Processing

**ç›®æ ‡**: æä¾›Chrome DevToolsçº§åˆ«çš„æ€§èƒ½åˆ†æèƒ½åŠ›

**å…·ä½“å®ç°**:

#### 1.1 æ·»åŠ chrome-devtools-frontendä¾èµ–

```json
// package.json
{
  "dependencies": {
    "chrome-devtools-frontend": "1.0.1524741"
  }
}
```

#### 1.2 åˆ›å»ºTraceParseræ¨¡å—

```typescript
// src/utils/TraceParser.ts

import * as TraceEngine from 'chrome-devtools-frontend/front_end/models/trace/trace.js';
import { PerformanceTraceFormatter } from 'chrome-devtools-frontend/front_end/models/ai_assistance/data_formatters/PerformanceTraceFormatter.js';
import { PerformanceInsightFormatter } from 'chrome-devtools-frontend/front_end/models/ai_assistance/data_formatters/PerformanceInsightFormatter.js';
import { AgentFocus } from 'chrome-devtools-frontend/front_end/models/ai_assistance/performance/AIContext.js';

export interface TraceResult {
  parsedTrace: TraceEngine.TraceModel.ParsedTrace;
  insights: TraceEngine.Insights.Types.TraceInsightSets | null;
}

export class TraceParser {
  private engine = TraceEngine.TraceModel.Model.createWithAllHandlers();

  /**
   * è§£ætrace buffer
   */
  async parseRawTraceBuffer(buffer: Buffer): Promise<TraceResult> {
    this.engine.resetProcessor();
    
    const asString = buffer.toString('utf-8');
    const data = JSON.parse(asString);
    const events = Array.isArray(data) ? data : data.traceEvents;
    
    await this.engine.parse(events);
    const parsedTrace = this.engine.parsedTrace();
    
    if (!parsedTrace) {
      throw new Error('Failed to parse trace');
    }

    return {
      parsedTrace,
      insights: parsedTrace.insights ?? null
    };
  }

  /**
   * ç”Ÿæˆtraceæ‘˜è¦
   */
  getTraceSummary(result: TraceResult): string {
    const focus = AgentFocus.fromParsedTrace(result.parsedTrace);
    const formatter = new PerformanceTraceFormatter(focus);
    return formatter.formatTraceSummary();
  }

  /**
   * è·å–ç‰¹å®šInsightçš„è¯¦ç»†ä¿¡æ¯
   */
  getInsightOutput(result: TraceResult, insightName: string): string {
    if (!result.insights) {
      throw new Error('No insights available');
    }

    const mainNavigationId = result.parsedTrace.data.Meta.mainFrameNavigations
      .at(0)?.args.data?.navigationId;

    const insightsForNav = result.insights.get(
      mainNavigationId ?? TraceEngine.Types.Events.NO_NAVIGATION
    );

    if (!insightsForNav) {
      throw new Error('No insights for navigation');
    }

    const matchingInsight = insightsForNav.model[insightName];
    if (!matchingInsight) {
      throw new Error(`No insight named ${insightName}`);
    }

    const formatter = new PerformanceInsightFormatter(
      AgentFocus.fromParsedTrace(result.parsedTrace),
      matchingInsight
    );
    return formatter.formatInsight();
  }

  /**
   * æå–æ‰©å±•ç›¸å…³çš„trace events
   */
  filterExtensionEvents(
    result: TraceResult, 
    extensionId: string
  ): TraceEngine.Types.Events.Event[] {
    // è¿‡æ»¤æ‰©å±•ç›¸å…³çš„äº‹ä»¶
    // 1. URLåŒ…å«chrome-extension://{extensionId}
    // 2. è„šæœ¬URLåŒ…å«æ‰©å±•è·¯å¾„
    // 3. Chrome APIè°ƒç”¨äº‹ä»¶
    
    const allEvents = result.parsedTrace.data.Renderer.allTraceEntries;
    const extensionUrl = `chrome-extension://${extensionId}`;
    
    return allEvents.filter(event => {
      // æ£€æŸ¥URL
      if ('args' in event && event.args) {
        const args = event.args as any;
        if (args.data?.url?.includes(extensionUrl)) return true;
        if (args.data?.scriptUrl?.includes(extensionUrl)) return true;
      }
      return false;
    });
  }
}
```

#### 1.3 å¢å¼ºExtensionPerformanceAnalyzer

```typescript
// src/handlers/extension/ExtensionPerformanceAnalyzer.ts (å¢å¼ºç‰ˆ)

import { TraceParser, TraceResult } from '../../utils/TraceParser.js';

export class ExtensionPerformanceAnalyzer {
  private traceParser: TraceParser;

  constructor(chromeManager: ChromeManager, pageManager: PageManager) {
    this.chromeManager = chromeManager;
    this.pageManager = pageManager;
    this.traceParser = new TraceParser();
  }

  /**
   * åˆ†ææ‰©å±•æ€§èƒ½ï¼ˆå¢å¼ºç‰ˆï¼‰
   */
  async analyzePerformance(options: PerformanceAnalysisOptions) {
    // 1. å½•åˆ¶trace
    const traceBuffer = await this.recordTrace(options.testUrl, options.duration);
    
    // 2. ä½¿ç”¨DevToolsè§£æå™¨
    const traceResult = await this.traceParser.parseRawTraceBuffer(traceBuffer);
    
    // 3. ç”Ÿæˆtraceæ‘˜è¦
    const traceSummary = this.traceParser.getTraceSummary(traceResult);
    
    // 4. æå–æ‰©å±•ç›¸å…³äº‹ä»¶
    const extensionEvents = this.traceParser.filterExtensionEvents(
      traceResult, 
      options.extensionId
    );
    
    // 5. è®¡ç®—æ‰©å±•ç‰¹å®šæŒ‡æ ‡
    const extensionMetrics = this.calculateExtensionMetrics(extensionEvents);
    
    // 6. è·å–Performance Insights
    const insights = this.extractInsights(traceResult);
    
    return {
      summary: traceSummary,
      extensionMetrics,
      insights,
      recommendations: this.generateRecommendations(extensionMetrics, insights)
    };
  }

  /**
   * æå–Performance Insights
   */
  private extractInsights(result: TraceResult) {
    if (!result.insights) return [];

    const insightNames = [
      'DocumentLatency',
      'LCPBreakdown', 
      'CLSCulprits',
      'RenderBlocking',
      'SlowCSSSelector'
    ];

    return insightNames.map(name => {
      try {
        return {
          name,
          details: this.traceParser.getInsightOutput(result, name)
        };
      } catch {
        return null;
      }
    }).filter(Boolean);
  }
}
```

#### 1.4 æ–°å¢MCPå·¥å…·

```typescript
// src/ChromeDebugServer.ts

/**
 * performance_get_insights - è·å–æ€§èƒ½æ´å¯Ÿ
 */
public async handlePerformanceGetInsights(args: { insightName: string }) {
  // ä»æœ€è¿‘ä¸€æ¬¡traceå½•åˆ¶ä¸­è·å–insights
  const lastTrace = this.context.getLastTrace();
  if (!lastTrace) {
    throw new Error('No trace recorded. Run analyze_extension_performance first.');
  }

  const insight = this.traceParser.getInsightOutput(lastTrace, args.insightName);
  
  return {
    content: [{
      type: 'text',
      text: JSON.stringify({ insight }, null, 2)
    }]
  };
}
```

**ä»·å€¼**:
- âœ… æä¾›Chrome DevToolsçº§åˆ«çš„æ€§èƒ½åˆ†æ
- âœ… è‡ªåŠ¨åŒ–Performance Insightsæå–
- âœ… ä¸“ä¸šçš„traceè§£æå’Œå¯è§†åŒ–
- âœ… ä¸Chrome DevToolså¯¹ç­‰çš„ä¸“ä¸šæ€§

**å¼€å‘å·¥æœŸ**: 2-3å‘¨  
**æŠ€æœ¯éš¾åº¦**: â­â­â­â­

---

### 2. å¢å¼ºè®¾å¤‡æ¨¡æ‹Ÿèƒ½åŠ›

**ç›®æ ‡**: æ”¯æŒåœ¨ä¸åŒè®¾å¤‡æ¡ä»¶ä¸‹æµ‹è¯•æ‰©å±•æ€§èƒ½

**å…·ä½“å®ç°**:

#### 2.1 æ·»åŠ CPUèŠ‚æµå·¥å…·

```typescript
// src/tools/emulation-tools.ts

/**
 * emulate_extension_cpu - æ‰©å±•CPUèŠ‚æµæµ‹è¯•
 * 
 * åœ¨CPUèŠ‚æµæ¡ä»¶ä¸‹æµ‹è¯•æ‰©å±•æ€§èƒ½
 */
export async function emulateExtensionCPU(args: {
  extensionId: string;
  throttlingRate: number; // 1-20x
  testUrl: string;
}) {
  const page = await getPage();
  
  // å¯ç”¨CPUèŠ‚æµ
  await page.emulateCPUThrottling(args.throttlingRate);
  
  // å¯¼èˆªåˆ°æµ‹è¯•é¡µé¢
  await page.goto(args.testUrl, { waitUntil: 'networkidle0' });
  
  // ç­‰å¾…æ‰©å±•åˆå§‹åŒ–
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  // æµ‹é‡æ€§èƒ½æŒ‡æ ‡
  const metrics = await page.metrics();
  
  // æ¢å¤CPU
  await page.emulateCPUThrottling(1);
  
  return {
    throttlingRate: args.throttlingRate,
    metrics: {
      taskDuration: metrics.TaskDuration,
      scriptDuration: metrics.ScriptDuration,
      layoutDuration: metrics.LayoutDuration
    },
    recommendation: args.throttlingRate > 1 
      ? `åœ¨${args.throttlingRate}x CPUèŠ‚æµä¸‹ï¼Œæ‰©å±•è¡¨ç°æ­£å¸¸`
      : 'å»ºè®®åœ¨4x CPUèŠ‚æµä¸‹æµ‹è¯•ä½ç«¯è®¾å¤‡æ€§èƒ½'
  };
}
```

#### 2.2 æ·»åŠ ç½‘ç»œèŠ‚æµå·¥å…·

```typescript
/**
 * emulate_extension_network - æ‰©å±•ç½‘ç»œèŠ‚æµæµ‹è¯•
 * 
 * åœ¨ä¸åŒç½‘ç»œæ¡ä»¶ä¸‹æµ‹è¯•æ‰©å±•è¡Œä¸º
 */
export async function emulateExtensionNetwork(args: {
  extensionId: string;
  networkCondition: 'Fast 3G' | 'Slow 3G' | 'Offline' | 'No emulation';
  testUrl: string;
}) {
  const page = await getPage();
  const { PredefinedNetworkConditions } = await import('puppeteer-core');
  
  // è®¾ç½®ç½‘ç»œæ¡ä»¶
  if (args.networkCondition === 'No emulation') {
    await page.emulateNetworkConditions(null);
  } else {
    const condition = PredefinedNetworkConditions[args.networkCondition];
    await page.emulateNetworkConditions(condition);
  }
  
  // å¯¼èˆªå¹¶æµ‹è¯•
  const startTime = Date.now();
  await page.goto(args.testUrl, { waitUntil: 'networkidle0' });
  const loadTime = Date.now() - startTime;
  
  // æ£€æŸ¥æ‰©å±•åŠŸèƒ½æ˜¯å¦æ­£å¸¸
  const extensionFunctional = await checkExtensionFunctional(args.extensionId, page);
  
  // æ¢å¤ç½‘ç»œ
  await page.emulateNetworkConditions(null);
  
  return {
    networkCondition: args.networkCondition,
    loadTime,
    extensionFunctional,
    recommendation: extensionFunctional 
      ? `æ‰©å±•åœ¨${args.networkCondition}æ¡ä»¶ä¸‹è¿è¡Œæ­£å¸¸`
      : `è­¦å‘Š: æ‰©å±•åœ¨${args.networkCondition}æ¡ä»¶ä¸‹åŠŸèƒ½å¼‚å¸¸`
  };
}
```

#### 2.3 ç»„åˆæµ‹è¯•å·¥å…·

```typescript
/**
 * test_extension_under_conditions - ç»¼åˆè®¾å¤‡æ¡ä»¶æµ‹è¯•
 * 
 * åœ¨å¤šç§è®¾å¤‡æ¡ä»¶ä¸‹æ‰¹é‡æµ‹è¯•æ‰©å±•
 */
export async function testExtensionUnderConditions(args: {
  extensionId: string;
  testUrl: string;
  conditions: Array<{
    name: string;
    cpu: number;
    network: string;
  }>;
}) {
  const results = [];
  
  for (const condition of args.conditions) {
    // CPUèŠ‚æµ
    await page.emulateCPUThrottling(condition.cpu);
    
    // ç½‘ç»œèŠ‚æµ
    if (condition.network !== 'No emulation') {
      const networkCondition = PredefinedNetworkConditions[condition.network];
      await page.emulateNetworkConditions(networkCondition);
    }
    
    // æµ‹è¯•
    const startTime = Date.now();
    await page.goto(args.testUrl, { waitUntil: 'networkidle0' });
    const loadTime = Date.now() - startTime;
    
    // æ£€æŸ¥æ‰©å±•åŠŸèƒ½
    const functional = await checkExtensionFunctional(args.extensionId, page);
    
    results.push({
      condition: condition.name,
      loadTime,
      functional,
      passed: functional && loadTime < 10000 // 10ç§’é˜ˆå€¼
    });
    
    // æ¢å¤
    await page.emulateCPUThrottling(1);
    await page.emulateNetworkConditions(null);
  }
  
  return {
    totalTests: results.length,
    passed: results.filter(r => r.passed).length,
    failed: results.filter(r => !r.passed).length,
    results
  };
}
```

**é¢„å®šä¹‰æµ‹è¯•æ¡ä»¶**:

```typescript
const COMMON_TEST_CONDITIONS = [
  { name: 'High-end Desktop', cpu: 1, network: 'No emulation' },
  { name: 'Mid-range Desktop', cpu: 2, network: 'Fast 3G' },
  { name: 'Low-end Mobile', cpu: 4, network: 'Slow 3G' },
  { name: 'Legacy Device', cpu: 6, network: 'Slow 3G' },
  { name: 'Offline Mode', cpu: 1, network: 'Offline' }
];
```

**ä»·å€¼**:
- âœ… æµ‹è¯•æ‰©å±•åœ¨ä½æ€§èƒ½è®¾å¤‡ä¸Šçš„è¡¨ç°
- âœ… æµ‹è¯•æ‰©å±•åœ¨å¼±ç½‘ç¯å¢ƒä¸‹çš„è¡Œä¸º
- âœ… å‘ç°æ€§èƒ½ç“¶é¢ˆå’Œå…¼å®¹æ€§é—®é¢˜
- âœ… æä¾›è®¾å¤‡è¦†ç›–ç‡æŠ¥å‘Š

**å¼€å‘å·¥æœŸ**: 1å‘¨  
**æŠ€æœ¯éš¾åº¦**: â­â­

---

### 3. å®Œå–„ç½‘ç»œç›‘æ§èƒ½åŠ›

**ç›®æ ‡**: æä¾›Chrome DevToolsçº§åˆ«çš„ç½‘ç»œåˆ†æèƒ½åŠ›

**å…·ä½“å®ç°**:

#### 3.1 å¢å¼ºç½‘ç»œè¯·æ±‚æ”¶é›†

```typescript
// src/handlers/extension/ExtensionNetworkMonitor.ts (å¢å¼ºç‰ˆ)

export class ExtensionNetworkMonitor {
  private requests: Map<string, NetworkRequest> = new Map();

  /**
   * å¼€å§‹ç›‘æ§ç½‘ç»œè¯·æ±‚
   */
  async startMonitoring(extensionId: string) {
    const page = await getPage();
    
    // å¯ç”¨ç½‘ç»œè¿½è¸ª
    await page.setRequestInterception(true);
    
    // ç›‘å¬requestäº‹ä»¶
    page.on('request', (request) => {
      const url = request.url();
      
      // åªæ”¶é›†æ‰©å±•ç›¸å…³çš„è¯·æ±‚
      if (this.isExtensionRequest(url, extensionId)) {
        this.requests.set(request._requestId, {
          id: request._requestId,
          url,
          method: request.method(),
          resourceType: request.resourceType(),
          headers: request.headers(),
          postData: request.postData(),
          timestamp: Date.now(),
          initiator: request.frame()?.url() || 'unknown'
        });
      }
      
      request.continue();
    });
    
    // ç›‘å¬responseäº‹ä»¶
    page.on('response', async (response) => {
      const request = response.request();
      const requestData = this.requests.get(request._requestId);
      
      if (requestData) {
        requestData.status = response.status();
        requestData.statusText = response.statusText();
        requestData.responseHeaders = response.headers();
        requestData.contentLength = parseInt(response.headers()['content-length'] || '0');
        requestData.timing = response.timing();
        
        // æ”¶é›†å“åº”ä½“ï¼ˆå°äº1MBï¼‰
        if (requestData.contentLength < 1024 * 1024) {
          try {
            requestData.responseBody = await response.text();
          } catch (e) {
            // å¿½ç•¥äºŒè¿›åˆ¶å†…å®¹
          }
        }
      }
    });
    
    // ç›‘å¬requestfinishedäº‹ä»¶
    page.on('requestfinished', (request) => {
      const requestData = this.requests.get(request._requestId);
      if (requestData) {
        requestData.finishedAt = Date.now();
        requestData.duration = requestData.finishedAt - requestData.timestamp;
      }
    });
    
    // ç›‘å¬requestfailedäº‹ä»¶
    page.on('requestfailed', (request) => {
      const requestData = this.requests.get(request._requestId);
      if (requestData) {
        requestData.failed = true;
        requestData.errorText = request.failure()?.errorText;
      }
    });
  }

  /**
   * è·å–ç½‘ç»œè¯·æ±‚ï¼ˆæ”¯æŒè¿‡æ»¤å’Œåˆ†é¡µï¼‰
   */
  getRequests(options: {
    resourceTypes?: string[];
    pageSize?: number;
    pageIdx?: number;
  }): NetworkRequest[] {
    let requests = Array.from(this.requests.values());
    
    // èµ„æºç±»å‹è¿‡æ»¤
    if (options.resourceTypes && options.resourceTypes.length > 0) {
      requests = requests.filter(r => 
        options.resourceTypes!.includes(r.resourceType)
      );
    }
    
    // æ’åºï¼ˆæŒ‰æ—¶é—´ï¼‰
    requests.sort((a, b) => a.timestamp - b.timestamp);
    
    // åˆ†é¡µ
    if (options.pageSize && options.pageIdx !== undefined) {
      const start = options.pageIdx * options.pageSize;
      const end = start + options.pageSize;
      requests = requests.slice(start, end);
    }
    
    return requests;
  }

  /**
   * å¯¼å‡ºä¸ºHARæ ¼å¼
   */
  exportToHAR(): HARFile {
    const requests = Array.from(this.requests.values());
    
    return {
      log: {
        version: '1.2',
        creator: {
          name: 'Chrome Extension Debug MCP',
          version: '4.0.0'
        },
        entries: requests.map(r => ({
          startedDateTime: new Date(r.timestamp).toISOString(),
          time: r.duration || 0,
          request: {
            method: r.method,
            url: r.url,
            httpVersion: 'HTTP/1.1',
            headers: this.formatHeaders(r.headers),
            queryString: this.parseQueryString(r.url),
            postData: r.postData ? {
              mimeType: r.headers['content-type'] || 'text/plain',
              text: r.postData
            } : undefined,
            headersSize: -1,
            bodySize: r.postData?.length || 0
          },
          response: {
            status: r.status || 0,
            statusText: r.statusText || '',
            httpVersion: 'HTTP/1.1',
            headers: this.formatHeaders(r.responseHeaders || {}),
            content: {
              size: r.contentLength || 0,
              mimeType: r.responseHeaders?.['content-type'] || 'text/plain',
              text: r.responseBody
            },
            redirectURL: '',
            headersSize: -1,
            bodySize: r.contentLength || 0
          },
          cache: {},
          timings: r.timing ? {
            blocked: 0,
            dns: r.timing.dnsEnd - r.timing.dnsStart,
            connect: r.timing.connectEnd - r.timing.connectStart,
            send: 0,
            wait: r.timing.receiveHeadersEnd - r.timing.sendEnd,
            receive: (r.duration || 0) - (r.timing.receiveHeadersEnd - r.timing.requestTime * 1000),
            ssl: r.timing.sslEnd - r.timing.sslStart
          } : {
            blocked: 0,
            dns: 0,
            connect: 0,
            send: 0,
            wait: 0,
            receive: 0,
            ssl: 0
          }
        }))
      }
    };
  }

  /**
   * åˆ†æç½‘ç»œæ¨¡å¼
   */
  analyzeNetworkPattern(): NetworkAnalysis {
    const requests = Array.from(this.requests.values());
    
    // æŒ‰èµ„æºç±»å‹åˆ†ç»„
    const byType: Record<string, number> = {};
    const byDomain: Record<string, number> = {};
    let totalSize = 0;
    let failedCount = 0;
    
    requests.forEach(r => {
      // èµ„æºç±»å‹ç»Ÿè®¡
      byType[r.resourceType] = (byType[r.resourceType] || 0) + 1;
      
      // åŸŸåç»Ÿè®¡
      try {
        const domain = new URL(r.url).hostname;
        byDomain[domain] = (byDomain[domain] || 0) + 1;
      } catch {}
      
      // æ€»å¤§å°
      totalSize += r.contentLength || 0;
      
      // å¤±è´¥è®¡æ•°
      if (r.failed) failedCount++;
    });
    
    return {
      totalRequests: requests.length,
      requestsByType: byType,
      requestsByDomain: byDomain,
      totalDataTransferred: totalSize,
      failedRequests: failedCount,
      averageRequestDuration: 
        requests.reduce((sum, r) => sum + (r.duration || 0), 0) / requests.length,
      recommendations: this.generateNetworkRecommendations(requests)
    };
  }

  /**
   * ç”Ÿæˆç½‘ç»œä¼˜åŒ–å»ºè®®
   */
  private generateNetworkRecommendations(requests: NetworkRequest[]): string[] {
    const recommendations: string[] = [];
    
    // æ£€æŸ¥è¯·æ±‚é¢‘ç‡
    if (requests.length > 100) {
      recommendations.push('ç½‘ç»œè¯·æ±‚è¿‡å¤šï¼Œè€ƒè™‘æ‰¹é‡è¯·æ±‚æˆ–ç¼“å­˜ç­–ç•¥');
    }
    
    // æ£€æŸ¥å¤§æ–‡ä»¶
    const largeRequests = requests.filter(r => (r.contentLength || 0) > 1024 * 1024);
    if (largeRequests.length > 0) {
      recommendations.push(`å‘ç°${largeRequests.length}ä¸ªå¤§æ–‡ä»¶è¯·æ±‚(>1MB)ï¼Œè€ƒè™‘å‹ç¼©æˆ–å»¶è¿ŸåŠ è½½`);
    }
    
    // æ£€æŸ¥å¤±è´¥è¯·æ±‚
    const failedRequests = requests.filter(r => r.failed);
    if (failedRequests.length > 0) {
      recommendations.push(`å‘ç°${failedRequests.length}ä¸ªå¤±è´¥è¯·æ±‚ï¼Œæ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–APIç«¯ç‚¹`);
    }
    
    // æ£€æŸ¥è·¨åŸŸè¯·æ±‚
    const domains = new Set(requests.map(r => {
      try {
        return new URL(r.url).hostname;
      } catch {
        return '';
      }
    }));
    if (domains.size > 10) {
      recommendations.push(`è¯·æ±‚æ¶‰åŠ${domains.size}ä¸ªä¸åŒåŸŸåï¼Œå¯èƒ½å½±å“æ€§èƒ½`);
    }
    
    return recommendations;
  }

  /**
   * åˆ¤æ–­æ˜¯å¦ä¸ºæ‰©å±•è¯·æ±‚
   */
  private isExtensionRequest(url: string, extensionId: string): boolean {
    return url.includes(`chrome-extension://${extensionId}`) ||
           url.includes('extension-specific-marker');
  }

  /**
   * æ ¼å¼åŒ–headersä¸ºHARæ ¼å¼
   */
  private formatHeaders(headers: Record<string, string>) {
    return Object.entries(headers).map(([name, value]) => ({ name, value }));
  }

  /**
   * è§£æURL query string
   */
  private parseQueryString(url: string) {
    try {
      const urlObj = new URL(url);
      return Array.from(urlObj.searchParams.entries()).map(([name, value]) => ({
        name,
        value
      }));
    } catch {
      return [];
    }
  }
}
```

#### 3.2 æ–°å¢MCPå·¥å…·

```typescript
/**
 * list_extension_requests - åˆ—å‡ºæ‰©å±•ç½‘ç»œè¯·æ±‚
 * 
 * æ”¯æŒèµ„æºç±»å‹è¿‡æ»¤å’Œåˆ†é¡µ
 */
export async function listExtensionRequests(args: {
  extensionId: string;
  resourceTypes?: string[]; // ['xhr', 'fetch', 'script', 'stylesheet', 'image']
  pageSize?: number;
  pageIdx?: number;
}) {
  const monitor = getExtensionNetworkMonitor();
  const requests = monitor.getRequests({
    resourceTypes: args.resourceTypes,
    pageSize: args.pageSize,
    pageIdx: args.pageIdx
  });
  
  return {
    total: monitor.getTotalRequests(),
    pageSize: args.pageSize,
    pageIdx: args.pageIdx,
    requests: requests.map(r => ({
      url: r.url,
      method: r.method,
      resourceType: r.resourceType,
      status: r.status,
      duration: r.duration,
      size: r.contentLength,
      failed: r.failed
    }))
  };
}

/**
 * export_extension_network_har - å¯¼å‡ºç½‘ç»œè¯·æ±‚ä¸ºHARæ ¼å¼
 */
export async function exportExtensionNetworkHAR(args: {
  extensionId: string;
  outputPath?: string;
}) {
  const monitor = getExtensionNetworkMonitor();
  const harData = monitor.exportToHAR();
  
  if (args.outputPath) {
    await fs.writeFile(args.outputPath, JSON.stringify(harData, null, 2));
    return { saved: true, path: args.outputPath };
  }
  
  return harData;
}

/**
 * analyze_extension_network - åˆ†ææ‰©å±•ç½‘ç»œæ¨¡å¼
 */
export async function analyzeExtensionNetwork(args: {
  extensionId: string;
}) {
  const monitor = getExtensionNetworkMonitor();
  return monitor.analyzeNetworkPattern();
}
```

**ä»·å€¼**:
- âœ… å®Œæ•´çš„ç½‘ç»œè¯·æ±‚ç›‘æ§
- âœ… HARæ ¼å¼å¯¼å‡ºï¼ˆå¯å¯¼å…¥Chrome DevToolsï¼‰
- âœ… èµ„æºç±»å‹è¿‡æ»¤å’Œåˆ†é¡µ
- âœ… ç½‘ç»œæ¨¡å¼åˆ†æå’Œä¼˜åŒ–å»ºè®®
- âœ… ä¸Chrome DevToolså¯¹ç­‰çš„ç½‘ç»œåˆ†æèƒ½åŠ›

**å¼€å‘å·¥æœŸ**: 1-2å‘¨  
**æŠ€æœ¯éš¾åº¦**: â­â­â­

---

## ğŸŸ¡ P1: é‡è¦åŠŸèƒ½å¢å¼ºï¼ˆå¼ºçƒˆå»ºè®®ï¼‰

### 4. DOMå¿«ç…§ä¸UIDå®šä½ç³»ç»Ÿ

**ç›®æ ‡**: æä¾›AIå‹å¥½çš„å…ƒç´ å®šä½èƒ½åŠ›

**å…·ä½“å®ç°**:

#### 4.1 åˆ›å»ºSnapshotGenerator

```typescript
// src/utils/SnapshotGenerator.ts

export interface ElementSnapshot {
  uid: string;
  role: string;
  name: string;
  value?: string;
  children: ElementSnapshot[];
}

export class SnapshotGenerator {
  private uidCounter = 0;
  private uidMap = new Map<string, ElementHandle>();

  /**
   * ç”Ÿæˆé¡µé¢å¿«ç…§
   */
  async generateSnapshot(page: Page): Promise<ElementSnapshot> {
    this.uidCounter = 0;
    this.uidMap.clear();
    
    // ä½¿ç”¨å¯è®¿é—®æ€§æ ‘API
    const snapshot = await page.accessibility.snapshot();
    
    if (!snapshot) {
      throw new Error('Failed to generate accessibility snapshot');
    }
    
    return this.processNode(snapshot, page);
  }

  /**
   * å¤„ç†èŠ‚ç‚¹
   */
  private processNode(node: any, page: Page): ElementSnapshot {
    const uid = `el_${this.uidCounter++}`;
    
    const result: ElementSnapshot = {
      uid,
      role: node.role || 'unknown',
      name: node.name || '',
      value: node.value,
      children: []
    };
    
    // é€’å½’å¤„ç†å­èŠ‚ç‚¹
    if (node.children) {
      result.children = node.children.map((child: any) => 
        this.processNode(child, page)
      );
    }
    
    return result;
  }

  /**
   * é€šè¿‡UIDè·å–å…ƒç´ 
   */
  async getElementByUid(uid: string, page: Page): Promise<ElementHandle | null> {
    // å®ç°UIDåˆ°ElementHandleçš„æ˜ å°„
    // è¿™éœ€è¦åœ¨ç”Ÿæˆå¿«ç…§æ—¶åŒæ—¶æ„å»ºæ˜ å°„å…³ç³»
    return this.uidMap.get(uid) || null;
  }

  /**
   * æ ¼å¼åŒ–å¿«ç…§ä¸ºæ–‡æœ¬
   */
  formatSnapshotAsText(snapshot: ElementSnapshot, indent = 0): string {
    const prefix = '  '.repeat(indent);
    let text = `${prefix}[${snapshot.uid}] ${snapshot.role}`;
    
    if (snapshot.name) {
      text += `: "${snapshot.name}"`;
    }
    
    if (snapshot.value) {
      text += ` = "${snapshot.value}"`;
    }
    
    text += '\n';
    
    snapshot.children.forEach(child => {
      text += this.formatSnapshotAsText(child, indent + 1);
    });
    
    return text;
  }
}
```

#### 4.2 æ–°å¢MCPå·¥å…·

```typescript
/**
 * take_extension_snapshot - ç”Ÿæˆæ‰©å±•é¡µé¢å¿«ç…§
 * 
 * ä¸ºé¡µé¢å…ƒç´ åˆ†é…UIDï¼Œä¾¿äºAIå®šä½
 */
export async function takeExtensionSnapshot(args: {
  tabId?: string;
}) {
  const page = args.tabId ? await getPageByTabId(args.tabId) : await getCurrentPage();
  const generator = new SnapshotGenerator();
  
  const snapshot = await generator.generateSnapshot(page);
  const textSnapshot = generator.formatSnapshotAsText(snapshot);
  
  // å­˜å‚¨å¿«ç…§ä»¥ä¾¿åç»­ä½¿ç”¨
  context.storeSnapshot(snapshot, generator);
  
  return {
    snapshot: textSnapshot,
    elementCount: countElements(snapshot),
    tip: 'ä½¿ç”¨å…ƒç´ çš„uidï¼ˆå¦‚el_42ï¼‰åœ¨å…¶ä»–å·¥å…·ä¸­å¼•ç”¨å…ƒç´ '
  };
}

/**
 * click_by_uid - é€šè¿‡UIDç‚¹å‡»å…ƒç´ 
 */
export async function clickByUid(args: {
  uid: string;
  dblClick?: boolean;
}) {
  const generator = context.getStoredSnapshotGenerator();
  if (!generator) {
    throw new Error('No snapshot available. Call take_extension_snapshot first.');
  }
  
  const page = await getCurrentPage();
  const element = await generator.getElementByUid(args.uid, page);
  
  if (!element) {
    throw new Error(`Element with uid ${args.uid} not found`);
  }
  
  if (args.dblClick) {
    await element.click({ clickCount: 2 });
  } else {
    await element.click();
  }
  
  return { success: true, message: 'Element clicked' };
}

/**
 * fill_by_uid - é€šè¿‡UIDå¡«å……è¡¨å•å…ƒç´ 
 */
export async function fillByUid(args: {
  uid: string;
  value: string;
}) {
  const generator = context.getStoredSnapshotGenerator();
  const page = await getCurrentPage();
  const element = await generator.getElementByUid(args.uid, page);
  
  if (!element) {
    throw new Error(`Element with uid ${args.uid} not found`);
  }
  
  await element.type(args.value);
  
  return { success: true, message: 'Element filled' };
}
```

**ä»·å€¼**:
- âœ… AIå‹å¥½çš„å…ƒç´ å®šä½
- âœ… ç¨³å®šçš„å…ƒç´ å¼•ç”¨ï¼ˆä¸å—DOMå˜åŒ–å½±å“ï¼‰
- âœ… å¯è®¿é—®æ€§æ ‘æ”¯æŒ
- âœ… æå‡è‡ªåŠ¨åŒ–æµ‹è¯•èƒ½åŠ›

**å¼€å‘å·¥æœŸ**: 1-2å‘¨  
**æŠ€æœ¯éš¾åº¦**: â­â­â­â­

---

### 5. é«˜çº§äº¤äº’å·¥å…·é›†

**ç›®æ ‡**: æ”¯æŒå¤æ‚UIäº¤äº’åœºæ™¯çš„è‡ªåŠ¨åŒ–æµ‹è¯•

**å…·ä½“å®ç°**:

#### 5.1 æ·»åŠ é«˜çº§äº¤äº’å·¥å…·

```typescript
// src/tools/interaction-tools.ts

/**
 * hover_element - æ‚¬åœå…ƒç´ 
 */
export async function hoverElement(args: {
  tabId?: string;
  uid?: string;
  selector?: string;
}) {
  const page = args.tabId ? await getPageByTabId(args.tabId) : await getCurrentPage();
  
  let element: ElementHandle;
  if (args.uid) {
    const generator = context.getStoredSnapshotGenerator();
    element = await generator.getElementByUid(args.uid, page);
  } else if (args.selector) {
    element = await page.$(args.selector);
  } else {
    throw new Error('Must provide either uid or selector');
  }
  
  if (!element) {
    throw new Error('Element not found');
  }
  
  await element.hover();
  
  return { success: true, message: 'Hovered over element' };
}

/**
 * drag_element - æ‹–æ‹½å…ƒç´ 
 */
export async function dragElement(args: {
  fromUid?: string;
  fromSelector?: string;
  toUid?: string;
  toSelector?: string;
}) {
  const page = await getCurrentPage();
  
  // è·å–æºå…ƒç´ å’Œç›®æ ‡å…ƒç´ 
  const fromElement = await resolveElement(page, args.fromUid, args.fromSelector);
  const toElement = await resolveElement(page, args.toUid, args.toSelector);
  
  if (!fromElement || !toElement) {
    throw new Error('Source or target element not found');
  }
  
  // æ‰§è¡Œæ‹–æ‹½
  await fromElement.drag(toElement);
  await toElement.drop(fromElement);
  
  return { success: true, message: 'Element dragged' };
}

/**
 * fill_form - æ‰¹é‡å¡«å……è¡¨å•
 */
export async function fillForm(args: {
  fields: Array<{
    uid?: string;
    selector?: string;
    value: string;
  }>;
}) {
  const page = await getCurrentPage();
  const results = [];
  
  for (const field of args.fields) {
    try {
      const element = await resolveElement(page, field.uid, field.selector);
      if (!element) {
        results.push({ ...field, success: false, error: 'Element not found' });
        continue;
      }
      
      await element.type(field.value);
      results.push({ ...field, success: true });
    } catch (error) {
      results.push({ ...field, success: false, error: error.message });
    }
  }
  
  return {
    totalFields: args.fields.length,
    succeeded: results.filter(r => r.success).length,
    failed: results.filter(r => !r.success).length,
    results
  };
}

/**
 * upload_file - æ–‡ä»¶ä¸Šä¼ 
 */
export async function uploadFile(args: {
  uid?: string;
  selector?: string;
  filePath: string;
}) {
  const page = await getCurrentPage();
  const element = await resolveElement(page, args.uid, args.selector);
  
  if (!element) {
    throw new Error('File input element not found');
  }
  
  // æ£€æŸ¥æ˜¯å¦ä¸ºæ–‡ä»¶è¾“å…¥
  const tagName = await element.evaluate(el => el.tagName);
  const type = await element.evaluate(el => (el as HTMLInputElement).type);
  
  if (tagName !== 'INPUT' || type !== 'file') {
    throw new Error('Element is not a file input');
  }
  
  // ä¸Šä¼ æ–‡ä»¶
  await element.uploadFile(args.filePath);
  
  return { success: true, message: 'File uploaded', path: args.filePath };
}

/**
 * handle_extension_dialog - å¤„ç†æ‰©å±•å¯¹è¯æ¡†
 */
export async function handleExtensionDialog(args: {
  action: 'accept' | 'dismiss';
  text?: string; // for prompt
}) {
  const page = await getCurrentPage();
  
  // è®¾ç½®å¯¹è¯æ¡†å¤„ç†å™¨
  page.once('dialog', async (dialog) => {
    if (args.action === 'accept') {
      await dialog.accept(args.text);
    } else {
      await dialog.dismiss();
    }
  });
  
  return { 
    success: true, 
    message: `Dialog handler set to ${args.action}`,
    tip: 'The next dialog will be automatically handled'
  };
}

/**
 * è¾…åŠ©å‡½æ•°ï¼šè§£æå…ƒç´ 
 */
async function resolveElement(
  page: Page, 
  uid?: string, 
  selector?: string
): Promise<ElementHandle | null> {
  if (uid) {
    const generator = context.getStoredSnapshotGenerator();
    return await generator.getElementByUid(uid, page);
  } else if (selector) {
    return await page.$(selector);
  }
  return null;
}
```

**ä»·å€¼**:
- âœ… æ”¯æŒæ‹–æ‹½ã€æ‚¬åœç­‰å¤æ‚äº¤äº’
- âœ… æ‰¹é‡è¡¨å•å¡«å……æå‡æ•ˆç‡
- âœ… æ–‡ä»¶ä¸Šä¼ æµ‹è¯•æ”¯æŒ
- âœ… å¯¹è¯æ¡†è‡ªåŠ¨åŒ–å¤„ç†

**å¼€å‘å·¥æœŸ**: 1å‘¨  
**æŠ€æœ¯éš¾åº¦**: â­â­

---

## ğŸŸ¢ P2: å¢å¼ºä½“éªŒåŠŸèƒ½ï¼ˆå»ºè®®å®ç°ï¼‰

### 6. æ™ºèƒ½ç­‰å¾…æœºåˆ¶

**ç›®æ ‡**: æå‡è‡ªåŠ¨åŒ–æµ‹è¯•çš„ç¨³å®šæ€§

**å…·ä½“å®ç°**:

```typescript
// src/utils/WaitHelper.ts

import { Locator } from 'puppeteer-core';

export class WaitHelper {
  /**
   * æ™ºèƒ½ç­‰å¾…å…ƒç´ ï¼ˆæ”¯æŒå¤šç§å®šä½ç­–ç•¥ï¼‰
   */
  static async waitForElement(page: Page, options: {
    text?: string;
    aria?: string;
    selector?: string;
    timeout?: number;
  }): Promise<ElementHandle> {
    const locators: Locator[] = [];
    
    // ARIAå®šä½å™¨
    if (options.aria) {
      page.frames().forEach(frame => {
        locators.push(frame.locator(`aria/${options.aria}`));
      });
    }
    
    // æ–‡æœ¬å®šä½å™¨
    if (options.text) {
      page.frames().forEach(frame => {
        locators.push(frame.locator(`text/${options.text}`));
      });
    }
    
    // Selectorå®šä½å™¨
    if (options.selector) {
      locators.push(page.locator(options.selector));
    }
    
    if (locators.length === 0) {
      throw new Error('At least one locator strategy must be provided');
    }
    
    // ä½¿ç”¨Locator.raceç«æ€ç­‰å¾…
    const locator = Locator.race(locators);
    
    if (options.timeout) {
      locator.setTimeout(options.timeout);
    }
    
    await locator.wait();
    
    return await locator.waitHandle();
  }

  /**
   * ç­‰å¾…æ‰©å±•å…ƒç´ ï¼ˆæ‰©å±•ç‰¹å®šçš„ç­‰å¾…ï¼‰
   */
  static async waitForExtensionElement(page: Page, options: {
    extensionId: string;
    selector: string;
    timeout?: number;
  }): Promise<ElementHandle> {
    const timeout = options.timeout || 30000;
    const startTime = Date.now();
    
    while (Date.now() - startTime < timeout) {
      // æ£€æŸ¥æ‰©å±•æ˜¯å¦æ³¨å…¥äº†å…ƒç´ 
      const element = await page.evaluateHandle((selector, extId) => {
        const elements = document.querySelectorAll(selector);
        for (const el of elements) {
          // æ£€æŸ¥å…ƒç´ æ˜¯å¦ç”±æ‰©å±•æ³¨å…¥
          if ((el as any).__extension_id === extId) {
            return el;
          }
        }
        return null;
      }, options.selector, options.extensionId);
      
      if (element) {
        return element as ElementHandle;
      }
      
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    throw new Error(`Extension element not found after ${timeout}ms`);
  }

  /**
   * ç­‰å¾…æ‰©å±•åˆå§‹åŒ–å®Œæˆ
   */
  static async waitForExtensionReady(page: Page, extensionId: string, timeout = 10000): Promise<void> {
    const startTime = Date.now();
    
    while (Date.now() - startTime < timeout) {
      const isReady = await page.evaluate((extId) => {
        // æ£€æŸ¥æ‰©å±•æ˜¯å¦å·²ç»åˆå§‹åŒ–
        return (window as any).__extension_ready?.[extId] === true;
      }, extensionId);
      
      if (isReady) {
        return;
      }
      
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    throw new Error(`Extension ${extensionId} not ready after ${timeout}ms`);
  }
}
```

**æ–°å¢MCPå·¥å…·**:

```typescript
/**
 * wait_for_extension_element - æ™ºèƒ½ç­‰å¾…æ‰©å±•å…ƒç´ 
 */
export async function waitForExtensionElement(args: {
  text?: string;
  aria?: string;
  selector?: string;
  extensionId?: string;
  timeout?: number;
}) {
  const page = await getCurrentPage();
  
  if (args.extensionId && args.selector) {
    await WaitHelper.waitForExtensionElement(page, {
      extensionId: args.extensionId,
      selector: args.selector,
      timeout: args.timeout
    });
  } else {
    await WaitHelper.waitForElement(page, {
      text: args.text,
      aria: args.aria,
      selector: args.selector,
      timeout: args.timeout
    });
  }
  
  return { success: true, message: 'Element found' };
}

/**
 * wait_for_extension_ready - ç­‰å¾…æ‰©å±•åˆå§‹åŒ–å®Œæˆ
 */
export async function waitForExtensionReady(args: {
  extensionId: string;
  timeout?: number;
}) {
  const page = await getCurrentPage();
  await WaitHelper.waitForExtensionReady(page, args.extensionId, args.timeout);
  
  return { success: true, message: 'Extension is ready' };
}
```

**ä»·å€¼**:
- âœ… å¤šç­–ç•¥å…ƒç´ å®šä½ï¼ˆARIA, text, selectorï¼‰
- âœ… æ™ºèƒ½ç«æ€ç­‰å¾…
- âœ… æ‰©å±•ç‰¹å®šçš„ç­‰å¾…é€»è¾‘
- âœ… æå‡æµ‹è¯•ç¨³å®šæ€§

**å¼€å‘å·¥æœŸ**: 1å‘¨  
**æŠ€æœ¯éš¾åº¦**: â­â­â­

---

### 7. æ‰©å±•å¼€å‘ä¸“ç”¨å·¥å…·

**ç›®æ ‡**: é’ˆå¯¹æ‰©å±•å¼€å‘ç—›ç‚¹æä¾›ä¸“ç”¨å·¥å…·

**å…·ä½“å®ç°**:

#### 7.1 æ‰©å±•æƒé™æ£€æµ‹

```typescript
/**
 * check_extension_permissions - æ£€æŸ¥æ‰©å±•æƒé™
 */
export async function checkExtensionPermissions(args: {
  extensionId: string;
}) {
  const cdpClient = await getCDPClient();
  
  // è·å–æ‰©å±•manifest
  const manifestUrl = `chrome-extension://${args.extensionId}/manifest.json`;
  const response = await fetch(manifestUrl);
  const manifest = await response.json();
  
  const declaredPermissions = manifest.permissions || [];
  const optionalPermissions = manifest.optional_permissions || [];
  
  // æ£€æŸ¥å®é™…æˆäºˆçš„æƒé™
  const grantedPermissions = await cdpClient.send('Browser.getGrantedPermissions', {
    origin: `chrome-extension://${args.extensionId}`
  });
  
  return {
    declared: declaredPermissions,
    optional: optionalPermissions,
    granted: grantedPermissions.permissions,
    missing: declaredPermissions.filter(p => !grantedPermissions.permissions.includes(p)),
    recommendations: generatePermissionRecommendations(manifest)
  };
}
```

#### 7.2 æ‰©å±•æ›´æ–°æ£€æµ‹

```typescript
/**
 * check_extension_updates - æ£€æŸ¥æ‰©å±•æ›´æ–°
 */
export async function checkExtensionUpdates(args: {
  extensionId: string;
}) {
  const cdpClient = await getCDPClient();
  
  // è·å–æ‰©å±•ä¿¡æ¯
  const extensions = await listExtensions();
  const extension = extensions.find(e => e.id === args.extensionId);
  
  if (!extension) {
    throw new Error('Extension not found');
  }
  
  // æ£€æŸ¥æ›´æ–°
  // æ³¨æ„ï¼šè¿™éœ€è¦æ‰©å±•æœ‰update_url
  if (extension.updateUrl) {
    const updateInfo = await fetch(extension.updateUrl);
    const data = await updateInfo.json();
    
    return {
      currentVersion: extension.version,
      latestVersion: data.version,
      hasUpdate: data.version !== extension.version,
      updateUrl: extension.updateUrl
    };
  }
  
  return {
    message: 'Extension does not have update URL configured'
  };
}
```

#### 7.3 æ‰©å±•å®‰å…¨å®¡è®¡

```typescript
/**
 * audit_extension_security - æ‰©å±•å®‰å…¨å®¡è®¡
 */
export async function auditExtensionSecurity(args: {
  extensionId: string;
}) {
  const issues: string[] = [];
  
  // 1. æ£€æŸ¥CSP
  const manifestUrl = `chrome-extension://${args.extensionId}/manifest.json`;
  const response = await fetch(manifestUrl);
  const manifest = await response.json();
  
  if (!manifest.content_security_policy) {
    issues.push('ç¼ºå°‘Content Security Policyé…ç½®');
  }
  
  // 2. æ£€æŸ¥æƒé™
  const sensitivePermissions = ['tabs', 'webRequest', 'cookies', 'history'];
  const declaredPermissions = manifest.permissions || [];
  const sensitiveDeclared = declaredPermissions.filter(p => 
    sensitivePermissions.includes(p)
  );
  
  if (sensitiveDeclared.length > 0) {
    issues.push(`ä½¿ç”¨äº†æ•æ„Ÿæƒé™: ${sensitiveDeclared.join(', ')}`);
  }
  
  // 3. æ£€æŸ¥å¤–éƒ¨è„šæœ¬
  if (manifest.content_scripts) {
    manifest.content_scripts.forEach((cs: any) => {
      if (cs.js) {
        cs.js.forEach((script: string) => {
          if (script.startsWith('http')) {
            issues.push(`å†…å®¹è„šæœ¬å¼•ç”¨äº†å¤–éƒ¨URL: ${script}`);
          }
        });
      }
    });
  }
  
  // 4. æ£€æŸ¥hostæƒé™
  const hostPermissions = manifest.host_permissions || [];
  if (hostPermissions.includes('<all_urls>')) {
    issues.push('ä½¿ç”¨äº†<all_urls>æƒé™ï¼Œå»ºè®®é™åˆ¶åˆ°ç‰¹å®šåŸŸå');
  }
  
  return {
    extensionId: args.extensionId,
    securityScore: Math.max(0, 100 - issues.length * 10),
    issues,
    recommendations: generateSecurityRecommendations(issues)
  };
}
```

**ä»·å€¼**:
- âœ… æƒé™ç®¡ç†è¾…åŠ©
- âœ… è‡ªåŠ¨æ›´æ–°æ£€æµ‹
- âœ… å®‰å…¨å®¡è®¡
- âœ… æå‡æ‰©å±•è´¨é‡

**å¼€å‘å·¥æœŸ**: 1-2å‘¨  
**æŠ€æœ¯éš¾åº¦**: â­â­â­

---

## ğŸ”µ P3: é•¿æœŸè§„åˆ’åŠŸèƒ½ï¼ˆå¯é€‰å®ç°ï¼‰

### 8. æ‰©å±•å•†åº—é›†æˆ

**ç›®æ ‡**: æ”¯æŒChrome Web Storeç›¸å…³æ“ä½œ

**å…·ä½“åŠŸèƒ½**:
- æŸ¥è¯¢æ‰©å±•å•†åº—ä¿¡æ¯
- æ£€æŸ¥æ‰©å±•è¯„åˆ†å’Œè¯„è®º
- å¯¹æ¯”ç«å“æ‰©å±•
- ç”Ÿæˆå‘å¸ƒæ¸…å•

**å¼€å‘å·¥æœŸ**: 2-3å‘¨  
**æŠ€æœ¯éš¾åº¦**: â­â­â­

---

## ğŸ“Š Part 3: å®æ–½è·¯çº¿å›¾ä¸ä¼˜å…ˆçº§

### æ€»è§ˆè¡¨

| åŠŸèƒ½ | ä¼˜å…ˆçº§ | å¼€å‘å·¥æœŸ | æŠ€æœ¯éš¾åº¦ | ç«äº‰åŠ›æå‡ | å»ºè®®å®æ–½æ—¶é—´ |
|------|--------|----------|----------|------------|--------------|
| Chrome DevTools Traceé›†æˆ | P0 | 2-3å‘¨ | â­â­â­â­ | â­â­â­â­â­ | ç¬¬1-3å‘¨ |
| è®¾å¤‡æ¨¡æ‹Ÿèƒ½åŠ› | P0 | 1å‘¨ | â­â­ | â­â­â­â­ | ç¬¬4å‘¨ |
| å®Œå–„ç½‘ç»œç›‘æ§ | P0 | 1-2å‘¨ | â­â­â­ | â­â­â­â­â­ | ç¬¬5-6å‘¨ |
| DOMå¿«ç…§ä¸UIDå®šä½ | P1 | 1-2å‘¨ | â­â­â­â­ | â­â­â­â­ | ç¬¬7-8å‘¨ |
| é«˜çº§äº¤äº’å·¥å…· | P1 | 1å‘¨ | â­â­ | â­â­â­ | ç¬¬9å‘¨ |
| æ™ºèƒ½ç­‰å¾…æœºåˆ¶ | P2 | 1å‘¨ | â­â­â­ | â­â­â­ | ç¬¬10å‘¨ |
| æ‰©å±•ä¸“ç”¨å·¥å…· | P2 | 1-2å‘¨ | â­â­â­ | â­â­â­ | ç¬¬11-12å‘¨ |
| æ‰©å±•å•†åº—é›†æˆ | P3 | 2-3å‘¨ | â­â­â­ | â­â­ | æœªæ¥è§„åˆ’ |

### åˆ†é˜¶æ®µå®æ–½è®¡åˆ’

#### ç¬¬ä¸€é˜¶æ®µ: æ€§èƒ½åˆ†æèƒ½åŠ›å¼ºåŒ–ï¼ˆç¬¬1-6å‘¨ï¼‰

**ç›®æ ‡**: è¾¾åˆ°Chrome DevTools MCPçš„æ€§èƒ½åˆ†ææ°´å¹³

**é‡Œç¨‹ç¢‘**:
- âœ… é›†æˆchrome-devtools-frontendåº“
- âœ… å®ç°Performance Insights
- âœ… æ·»åŠ è®¾å¤‡æ¨¡æ‹Ÿå·¥å…·
- âœ… å®Œå–„ç½‘ç»œç›‘æ§å’ŒHARå¯¼å‡º

**é¢„æœŸäº§å‡º**:
- æ–°å¢6ä¸ªå·¥å…·
- å·¥å…·æ€»æ•°: 30ä¸ª
- æ€§èƒ½åˆ†æèƒ½åŠ›: ä¸Chrome DevTools MCPå¯¹ç­‰

#### ç¬¬äºŒé˜¶æ®µ: UIè‡ªåŠ¨åŒ–èƒ½åŠ›æå‡ï¼ˆç¬¬7-10å‘¨ï¼‰

**ç›®æ ‡**: æ”¯æŒå¤æ‚UIäº¤äº’åœºæ™¯çš„è‡ªåŠ¨åŒ–æµ‹è¯•

**é‡Œç¨‹ç¢‘**:
- âœ… å®ç°DOMå¿«ç…§ä¸UIDå®šä½
- âœ… æ·»åŠ é«˜çº§äº¤äº’å·¥å…·ï¼ˆdrag, hover, fill_formç­‰ï¼‰
- âœ… å®ç°æ™ºèƒ½ç­‰å¾…æœºåˆ¶

**é¢„æœŸäº§å‡º**:
- æ–°å¢7ä¸ªå·¥å…·
- å·¥å…·æ€»æ•°: 37ä¸ª
- UIè‡ªåŠ¨åŒ–èƒ½åŠ›: å¤§å¹…æå‡

#### ç¬¬ä¸‰é˜¶æ®µ: æ‰©å±•å¼€å‘ä½“éªŒä¼˜åŒ–ï¼ˆç¬¬11-12å‘¨ï¼‰

**ç›®æ ‡**: é’ˆå¯¹æ‰©å±•å¼€å‘ç—›ç‚¹æä¾›ä¸“ç”¨å·¥å…·

**é‡Œç¨‹ç¢‘**:
- âœ… æƒé™æ£€æµ‹å·¥å…·
- âœ… å®‰å…¨å®¡è®¡å·¥å…·
- âœ… æ›´æ–°æ£€æµ‹å·¥å…·

**é¢„æœŸäº§å‡º**:
- æ–°å¢3ä¸ªå·¥å…·
- å·¥å…·æ€»æ•°: 40ä¸ª
- æ‰©å±•å¼€å‘ä½“éªŒ: å…¨é¢ä¼˜åŒ–

---

## ğŸ’ Part 4: æ ¸å¿ƒç«äº‰åŠ›åˆ†æ

### å®æ–½åçš„ç«äº‰åŠ›å¯¹æ¯”

| èƒ½åŠ›ç»´åº¦ | å®æ–½å‰ | å®æ–½å | Chrome DevTools MCP |
|----------|--------|--------|---------------------|
| **æ‰©å±•è°ƒè¯•** | â­â­â­â­â­ | â­â­â­â­â­ | âŒ æ—  |
| **æ€§èƒ½åˆ†æ** | â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ |
| **ç½‘ç»œç›‘æ§** | â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ |
| **è®¾å¤‡æ¨¡æ‹Ÿ** | âŒ æ—  | â­â­â­â­ | â­â­â­â­ |
| **UIè‡ªåŠ¨åŒ–** | â­â­ | â­â­â­â­â­ | â­â­â­â­â­ |
| **è¿œç¨‹è°ƒè¯•** | â­â­â­â­â­ | â­â­â­â­â­ | âŒ æ—  |
| **å·¥å…·æ•°é‡** | 24ä¸ª | 40+ä¸ª | 26ä¸ª |

### å·®å¼‚åŒ–ä»·å€¼ä¸»å¼ 

**Chrome Extension Debug MCPï¼ˆå®æ–½åï¼‰**:
- âœ… **å”¯ä¸€ä¸“æ³¨æ‰©å±•è°ƒè¯•çš„ä¸“ä¸šå·¥å…·**
- âœ… **æ€§èƒ½åˆ†æä¸Chrome DevTools MCPå¯¹ç­‰**
- âœ… **ç‹¬æœ‰çš„è¿œç¨‹è°ƒè¯•èƒ½åŠ›**
- âœ… **å®Œæ•´çš„æ‰©å±•å¼€å‘ç”Ÿå‘½å‘¨æœŸæ”¯æŒ**
- âœ… **40+ä¸“ä¸šå·¥å…·ï¼Œè¦†ç›–æ‰€æœ‰åœºæ™¯**

**ç›®æ ‡å®šä½**: 
> **æ‰©å±•å¼€å‘è°ƒè¯•çš„è¡Œä¸šæ ‡å‡†å·¥å…·ï¼Œé›†ä¸“ä¸šæ€§ã€å®Œæ•´æ€§ã€ä¾¿æ·æ€§äºä¸€ä½“**

---

## ğŸ¯ Part 5: å…·ä½“å»ºè®®

### å¯¹æ‰©å±•å¼€å‘è€…çš„ä»·å€¼

#### 1. **æ€§èƒ½ä¼˜åŒ–åœºæ™¯**
- ä½¿ç”¨`analyze_extension_performance` + DevTools Insights â†’ ç²¾å‡†å®šä½æ€§èƒ½ç“¶é¢ˆ
- ä½¿ç”¨`test_extension_under_conditions` â†’ æµ‹è¯•ä¸åŒè®¾å¤‡æ¡ä»¶ä¸‹çš„è¡¨ç°
- ä½¿ç”¨`export_extension_network_har` â†’ å¯¼å‡ºç½‘ç»œæ•°æ®åˆ°Chrome DevToolsåˆ†æ

#### 2. **è‡ªåŠ¨åŒ–æµ‹è¯•åœºæ™¯**
- ä½¿ç”¨`take_extension_snapshot` â†’ ç”Ÿæˆé¡µé¢å¿«ç…§
- ä½¿ç”¨`click_by_uid` / `fill_by_uid` â†’ ç¨³å®šçš„å…ƒç´ äº¤äº’
- ä½¿ç”¨`fill_form` â†’ æ‰¹é‡è¡¨å•æµ‹è¯•
- ä½¿ç”¨`wait_for_extension_element` â†’ æ™ºèƒ½ç­‰å¾…

#### 3. **å…¼å®¹æ€§æµ‹è¯•åœºæ™¯**
- ä½¿ç”¨`test_extension_on_multiple_pages` â†’ æ‰¹é‡é¡µé¢æµ‹è¯•
- ä½¿ç”¨`emulate_extension_cpu` / `emulate_extension_network` â†’ å¼±è®¾å¤‡æµ‹è¯•
- ä½¿ç”¨`content_script_status` â†’ æ³¨å…¥å†²çªæ£€æµ‹

#### 4. **å®‰å…¨å®¡è®¡åœºæ™¯**
- ä½¿ç”¨`audit_extension_security` â†’ å®‰å…¨æ¼æ´æ‰«æ
- ä½¿ç”¨`check_extension_permissions` â†’ æƒé™æ£€æŸ¥
- ä½¿ç”¨`analyze_extension_network` â†’ ç½‘ç»œè¡Œä¸ºåˆ†æ

### å®æ–½å»ºè®®

#### çŸ­æœŸï¼ˆ1-2ä¸ªæœˆï¼‰
**é‡ç‚¹**: P0åŠŸèƒ½

**å¿…é¡»å®ç°**:
1. Chrome DevTools Traceé›†æˆ
2. è®¾å¤‡æ¨¡æ‹Ÿèƒ½åŠ›
3. å®Œå–„ç½‘ç»œç›‘æ§

**é¢„æœŸæˆæœ**:
- å·¥å…·æ•°: 30ä¸ª
- æ€§èƒ½åˆ†æèƒ½åŠ›è¾¾åˆ°è¡Œä¸šé¢†å…ˆæ°´å¹³
- è¡¥é½å…³é”®çŸ­æ¿

#### ä¸­æœŸï¼ˆ3-4ä¸ªæœˆï¼‰
**é‡ç‚¹**: P1åŠŸèƒ½

**å¿…é¡»å®ç°**:
4. DOMå¿«ç…§ä¸UIDå®šä½
5. é«˜çº§äº¤äº’å·¥å…·

**é¢„æœŸæˆæœ**:
- å·¥å…·æ•°: 37ä¸ª
- UIè‡ªåŠ¨åŒ–èƒ½åŠ›å¤§å¹…æå‡
- æ‰©å±•æµ‹è¯•æ›´åŠ ç¨³å®šå’Œé«˜æ•ˆ

#### é•¿æœŸï¼ˆ5-6ä¸ªæœˆï¼‰
**é‡ç‚¹**: P2-P3åŠŸèƒ½

**å¯é€‰å®ç°**:
6. æ™ºèƒ½ç­‰å¾…æœºåˆ¶
7. æ‰©å±•ä¸“ç”¨å·¥å…·
8. æ‰©å±•å•†åº—é›†æˆ

**é¢„æœŸæˆæœ**:
- å·¥å…·æ•°: 40+ä¸ª
- æˆä¸ºæ‰©å±•å¼€å‘è°ƒè¯•çš„è¡Œä¸šæ ‡å‡†
- å…¨é¢è¶…è¶ŠChrome DevTools MCPï¼ˆåœ¨æ‰©å±•é¢†åŸŸï¼‰

---

## ğŸ“ é™„å½•: å‚è€ƒèµ„æº

### Chrome DevTools MCPæºç å‚è€ƒ

**æ ¸å¿ƒæ–‡ä»¶**:
- `src/trace-processing/parse.ts` - Traceè§£æå®ç°
- `src/tools/performance.ts` - æ€§èƒ½å·¥å…·å®ç°
- `src/tools/network.ts` - ç½‘ç»œå·¥å…·å®ç°
- `src/tools/emulation.ts` - è®¾å¤‡æ¨¡æ‹Ÿå®ç°
- `src/tools/snapshot.ts` - DOMå¿«ç…§å®ç°
- `src/tools/input.ts` - é«˜çº§äº¤äº’å®ç°

### ç›¸å…³ä¾èµ–

```json
{
  "chrome-devtools-frontend": "1.0.1524741",
  "puppeteer-core": "24.23.0"
}
```

### æŠ€æœ¯æ–‡æ¡£

- [Chrome DevTools Protocol](https://chromedevtools.github.io/devtools-protocol/)
- [Puppeteer API](https://pptr.dev/)
- [Chrome Extensions API](https://developer.chrome.com/docs/extensions/)
- [Performance Insights](https://developer.chrome.com/docs/devtools/performance-insights/)

---

**æŠ¥å‘Šç”Ÿæˆæ—¶é—´**: 2025-01-10  
**å»ºè®®æœ‰æ•ˆæœŸ**: 6ä¸ªæœˆ  
**ä¸‹æ¬¡è¯„ä¼°æ—¶é—´**: 2025-07-10

---

## ğŸ¯ æ ¸å¿ƒç»“è®º

1. **å½“å‰ä¼˜åŠ¿**: æ‰©å±•ä¸“ä¸šè°ƒè¯•èƒ½åŠ›æ˜¯æ ¸å¿ƒç«äº‰åŠ›ï¼Œå¿…é¡»ä¿æŒ
2. **å…³é”®çŸ­æ¿**: æ€§èƒ½åˆ†ææ·±åº¦ã€è®¾å¤‡æ¨¡æ‹Ÿã€é«˜çº§äº¤äº’
3. **å®æ–½ä¼˜å…ˆçº§**: P0åŠŸèƒ½å¿…é¡»å®ç°ï¼ŒP1åŠŸèƒ½å¼ºçƒˆå»ºè®®ï¼ŒP2-P3æŒ‰éœ€é€‰æ‹©
4. **é¢„æœŸæˆæœ**: 6ä¸ªæœˆå†…æˆä¸ºæ‰©å±•å¼€å‘è°ƒè¯•çš„è¡Œä¸šæ ‡å‡†å·¥å…·
5. **æŠ•å…¥äº§å‡º**: çº¦12å‘¨å¼€å‘æŠ•å…¥ï¼Œæ¢å–é•¿æœŸç«äº‰åŠ›ä¼˜åŠ¿

**å»ºè®®**: ç«‹å³å¯åŠ¨P0åŠŸèƒ½çš„å®æ–½ï¼Œåˆ†3ä¸ªé˜¶æ®µå®Œæˆæ‰€æœ‰å¢å¼ºåŠŸèƒ½ã€‚

